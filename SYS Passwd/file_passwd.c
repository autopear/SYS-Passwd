/*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * "Portions Copyright (c) 1999 Apple Computer, Inc.  All Rights
 * Reserved.  This file contains Original Code and/or Modifications of
 * Original Code as defined in and that are subject to the Apple Public
 * Source License Version 1.0 (the 'License').  You may not use this file
 * except in compliance with the License.  Please obtain a copy of the
 * License at http://www.apple.com/publicsource and read it before using
 * this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License."
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <pwd.h>
#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <sysexits.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include "stringops.h"
#include "file_passwd.h"

#define TEMP_FILE_TEMPLATE "/var/run/.pwtmpXXXXXX"

#define _PASSWD_FILE "/etc/master.passwd"
#define _COMPAT_FILE "/etc/passwd"
#define _PASSWD_FIELDS 10
//#define _PASSWORD_LEN 8
#define BUFSIZE 8192

static char *saltchars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./";

char *
getAline(FILE *fp)
{
	static char s[BUFSIZE];
	int len;

    s[0] = '\0';

    fgets(s, BUFSIZE, fp);
    if (s == NULL || s[0] == '\0') return NULL;

	if (s[0] == '#') return s;

	len = strlen(s) - 1;
	s[len] = '\0';

	return s;
}

struct passwd *
parse_user(char *line)
{
	static struct passwd pw = {0};
	char **tokens;
	int i, len;

	if (pw.pw_name != NULL) free(pw.pw_name);
	pw.pw_name = NULL;
	if (pw.pw_passwd != NULL) free(pw.pw_passwd);
	pw.pw_passwd = NULL;
	if (pw.pw_gecos != NULL) free(pw.pw_gecos);
	pw.pw_gecos = NULL;
	if (pw.pw_dir != NULL) free(pw.pw_dir);
	pw.pw_dir = NULL;
	if (pw.pw_shell != NULL) free(pw.pw_shell);
	pw.pw_shell = NULL;
	if (pw.pw_class != NULL) free(pw.pw_class);
	pw.pw_class = NULL;

	if (line == NULL) return (struct passwd *)NULL;
	tokens = explode(line, ':');
	len = listLength(tokens);

	if (len != _PASSWD_FIELDS)
	{
		freeList(tokens);
		return (struct passwd *)NULL;
	}

	i = 0;
	pw.pw_name = tokens[i++];
	pw.pw_passwd = tokens[i++];
	pw.pw_uid = atoi(tokens[i]);
	free(tokens[i++]);
	pw.pw_gid = atoi(tokens[i]);
	free(tokens[i++]);
	pw.pw_class = tokens[i++];
	pw.pw_change = atoi(tokens[i]);
	free(tokens[i++]);
	pw.pw_expire = atoi(tokens[i]);
	free(tokens[i++]);
	pw.pw_gecos = tokens[i++];
	pw.pw_dir = tokens[i++];
	pw.pw_shell = tokens[i++];

	return &pw;
}

struct passwd *
find_user(char *uname, FILE *fp)
{
	char *line;
	struct passwd *pw;

	rewind(fp);

	while (NULL != (line = getAline(fp)))
	{
		if (line[0] == '#') continue;
		pw = parse_user(line);
		if (pw == (struct passwd *)NULL) continue;
		if (!strcmp(uname, pw->pw_name)) return pw;
	}

	pw = parse_user(NULL);
	return (struct passwd *)NULL;
}

int
rewrite_file(char *pwname, FILE *fp, struct passwd *newpw)
{
	char *line;
	struct passwd *pw;
	FILE *tfp, *cfp;
	int fd;
	char fname[256];
	
	sprintf(fname, "%s.%.5d", TEMP_FILE_TEMPLATE, getpid());
	fd = mkstemps(fname, 6);
	if (fd == -1)
	{
		return ERR_TEMP_CREATE;
	}
	if (fchmod(fd, (S_IRUSR | S_IWUSR)) != 0)
	{
		close(fd);
		unlink(fname);
		return ERR_TEMP_PERMISSON;
	}
	tfp = fdopen(fd, "w+");
	if (tfp == NULL)
	{
		close(fd);
		unlink(fname);
		return ERR_TEMP_WRITE;
	}
	
	cfp = NULL;
	if (!strcmp(pwname, _PASSWD_FILE))
	{
		cfp = fopen(_COMPAT_FILE, "w");
		if (cfp == NULL)
		{
			return ERR_COMPAT_FILE_WRITE;
		}
	}

	if (cfp != NULL)
	{
		fprintf(cfp, "#\n");
		fprintf(cfp, "# 4.3BSD-compatable User Database\n");
		fprintf(cfp, "#\n");
		fprintf(cfp, "# Note that this file is not consulted for login.\n");
		fprintf(cfp, "# It only exisits for compatability with 4.3BSD utilities.\n");
		fprintf(cfp, "#\n");
		fprintf(cfp, "# This file is automatically re-written by various system utilities.\n");
		fprintf(cfp, "# Do not edit this file.  Changes will be lost.\n");
		fprintf(cfp, "#\n");
	}
	
	rewind(fp);

	while (NULL != (line = getAline(fp)))
	{
		if (line[0] == '#')
		{
			fprintf(tfp, "%s", line);
			continue;
		}

		pw = parse_user(line);
		if (pw == (struct passwd *)NULL)
		{
			fprintf(stderr, "warning: bad format for entry: \"%s\"\n", line);
			fprintf(tfp, "%s\n", line);
			if (cfp != NULL) fprintf(cfp, "%s\n", line);
			continue;
		}

		if (strcmp(newpw->pw_name, pw->pw_name))
		{
			fprintf(tfp, "%s\n", line);
			if (cfp != NULL)
			{
				fprintf(cfp, "%s:",pw->pw_name);
				if ((pw->pw_passwd == NULL) || (pw->pw_passwd[0] == '\0'))
					fprintf(cfp, ":");
				else
					fprintf(cfp, "*:");
				fprintf(cfp, "%d:%d:%s:%s:%s\n",
					pw->pw_uid, pw->pw_gid, pw->pw_gecos,
					pw->pw_dir, pw->pw_shell);
			}
			continue;
		}
		
		fprintf(tfp, "%s:%s:%d:%d:%s:%ld:%ld:%s:%s:%s\n",
			newpw->pw_name, newpw->pw_passwd, newpw->pw_uid, newpw->pw_gid,
			newpw->pw_class, newpw->pw_change, newpw->pw_expire,
			newpw->pw_gecos, newpw->pw_dir, newpw->pw_shell);
		if (cfp != NULL)
		{
			fprintf(cfp, "%s:",newpw->pw_name);
			if ((newpw->pw_passwd == NULL) || (newpw->pw_passwd[0] == '\0'))
				fprintf(cfp, ":");
			else
				fprintf(cfp, "*:");
			fprintf(cfp, "%d:%d:%s:%s:%s\n",
				newpw->pw_uid, newpw->pw_gid, newpw->pw_gecos,
				newpw->pw_dir, newpw->pw_shell);
		}
	}

	if (cfp != NULL) fclose(cfp);
	fclose(fp);
	
	rewind(tfp);

	fp = fopen(pwname, "w");
	if (fp == NULL)
	{
		fprintf(stderr, "ERROR: can't update \"%s\"\n", pwname);
		fprintf(stderr, "new passwd file is \"%s\"\n", fname);
		return ERR_PASSWD_FILE_WRITE;
	}
	
	while (NULL != (line = getAline(tfp)))
	{
		fprintf(fp, "%s", line);
		if (line[0] != '#') fprintf(fp, "\n");
	}
	fclose(fp);
	fclose(tfp);
	unlink(fname);

	return 0;
}

int
file_passwd(char *uname, int isroot, const char *old_pw, const char *new_pw)
{
	FILE *fp=NULL;
	char *fname;
	struct passwd *pw;
	struct passwd newpw={0};
	struct stat sb;
	int error_id = 0;
	char salt[9];
	static char nbuf[_PASSWORD_LEN+1]={0};
	
	fname = _PASSWD_FILE;
	
	umask((S_IRWXG | S_IRWXO));
        
	if ( lstat(fname, &sb) != 0 )
	{
		return ERR_PASSWD_FILE_NO_EXIST;
	}
	
	fp = fopen(fname, "a+");
	
	if (fp == NULL)
	{
		return ERR_PASSWD_FILE_WRITE;
	}
	if (fchmod(fileno(fp), (S_IRUSR | S_IWUSR)) != 0)
	{
		error_id = ERR_PASSWD_FILE_PERMISSON;
		goto err;
	}
	
	pw = find_user(uname, fp);
	if (pw == (struct passwd *)NULL)
	{
		error_id = ERR_USER_NO_EXIST;
		goto err;
	}
	if (isroot == 0)
	{
        if (strcmp(crypt(old_pw, pw->pw_passwd), pw->pw_passwd))
        {
            error_id = ERR_OLD_PW_WRONG;
            goto err;
        }
	}

	nbuf[0] = '\0';
	snprintf( nbuf, sizeof(nbuf), "%s", new_pw );
	/*
	 * Create a random salt
	 */
	srandom((int)time((time_t *)NULL));
	salt[0] = saltchars[random() % strlen(saltchars)];
	salt[1] = saltchars[random() % strlen(saltchars)];
	salt[2] = '\0';
	new_pw = crypt(nbuf, salt);

	newpw.pw_name = copyString(pw->pw_name);
	newpw.pw_passwd = copyString(new_pw);
	newpw.pw_class = copyString(pw->pw_class);
	newpw.pw_gecos = copyString(pw->pw_gecos);
	newpw.pw_dir = copyString(pw->pw_dir);
	newpw.pw_shell = copyString(pw->pw_shell);
	newpw.pw_uid = pw->pw_uid;
	newpw.pw_gid = pw->pw_gid;
	newpw.pw_change = pw->pw_change;
	newpw.pw_expire = pw->pw_expire;

	/*
	 * Re-write the file
	 */
	error_id = rewrite_file(fname, fp, &newpw);

	/*
	 * Clean up memory
	 */
	free(newpw.pw_name);
	free(newpw.pw_passwd);
	free(newpw.pw_class);
	free(newpw.pw_gecos);
	free(newpw.pw_dir);
	free(newpw.pw_shell);

err:
	pw = parse_user(NULL);
	fclose(fp);

	return error_id;
}
